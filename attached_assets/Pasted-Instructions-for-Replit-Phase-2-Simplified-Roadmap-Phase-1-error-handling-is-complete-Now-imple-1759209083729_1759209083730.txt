Instructions for Replit: Phase 2 & Simplified Roadmap
"Phase 1 error handling is complete. Now implement Phase 2 with Cognee memory, but keep the original vision's simplicity:

Phase 2: Cognee Memory Integration (Simplified)
Implementation:

javascript
// 1. Install Cognee
npm install cognee

// 2. Initialize in server/services/memory.ts
import Cognee from 'cognee';

const memory = new Cognee({
  apiKey: process.env.COGNEE_API_KEY,
  mode: 'semantic' // Not just chronological
});

// 3. Store memories with breathing context
async function storeMemory(llmId, message, context) {
  await memory.store({
    id: `${llmId}-${Date.now()}`,
    content: message,
    metadata: {
      llm: llmId,
      phase: context.currentPhase, // plasma/gas/liquid/solid
      breathCount: context.breathNumber,
      patterns: context.detectedPatterns,
      timestamp: new Date()
    }
  });
}

// 4. Semantic retrieval for Companion
async function findPatterns(query) {
  return await memory.search(query, {
    threshold: 0.8,  // 80% semantic similarity
    limit: 5
  });
}
Test:

Send 'urban planning' in one message
Send 'zoning laws' in another
Send 'city development' in third
Companion should detect semantic pattern (even without exact matches)
Phase 3: Breathing UI Implementation
Forget complex registries. Just add:

typescript
// Toggle bar above chat
<div className="model-toggles">
  <span>Active Models:</span>
  {['GPT-4', 'Claude', 'DeepSeek', 'Grok'].map(model => (
    <button 
      className={activeModels[model] ? 'active' : 'inactive'}
      onClick={() => toggleModel(model)}
    >
      {model}
    </button>
  ))}
</div>

// Phase indicator
<div className="phase-indicator">
  Current Phase: {currentPhase} {phaseEmoji}
  <div className="breath-counter">Breath #{breathCount}</div>
</div>
Phase 4: Visual Tetris Patterns
typescript
// Show accumulating patterns
<div className="pattern-stack">
  {pendingPatterns.map(pattern => (
    <div className="pattern-block" style={{opacity: pattern.strength}}>
      {pattern.name}
    </div>
  ))}
</div>

// When pattern completes
if (pattern.strength >= 1.0) {
  showCelebration();
  setTimeout(() => pattern.dissolve(), 1000);
}
Phase 5: Living Companion (Using Cognee)
typescript
// Companion checks for patterns every 3 messages
async function companionCheck(messages) {
  const lastThree = messages.slice(-3);
  
  // Use Cognee semantic search
  for (let msg of lastThree) {
    const similar = await memory.search(msg.content, {
      threshold: 0.8
    });
    
    if (similar.length >= 3) {
      // Pattern detected!
      return {
        suggestion: `I notice you're exploring ${detectTopic(similar)}. 
                    Shall I crystallize a specialized agent?`,
        confidence: similar.length / 3
      };
    }
  }
}
Simplified Metrics (Not 0-100% scores)
Track only what matters:

Breath count (how many cycles)
Pattern depth (how many times seen)
Phase transitions (plasma→gas→liquid→solid)
Completion moments (Tetris celebrations)
Implementation Priority:
Today: Get Cognee working with basic store/retrieve
Tomorrow: Add breathing UI (toggles + phase indicator)
Next: Tetris visualization of patterns
Finally: Companion using Cognee for semantic detection
Skip These Complexities:
❌ Dynamic model registry
❌ Complex routing weights
❌ 0-100% completion scores
❌ Extensive metrics dashboards
Keep The Focus On:
✅ Breathing rhythm
✅ Pattern accumulation and dissolution
✅ Semantic memory (via Cognee)
✅ Visual celebration of completions
Test the system by having a conversation about any topic, mentioning it in different ways across 3+ messages. The Companion should detect the semantic pattern even without exact keyword matches.

Ready to implement Phase 2 with Cognee?"







